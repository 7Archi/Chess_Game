#include<iostream>
#include<string>
#include<stdlib.h>
int a[8][8];
int w[8][8];

// рывок
int Rush(int a[8][8], int w[8][8], int y, int x, int y1, int x1)
{
    if (a[y][x] == 1)
    {
        if ((&a[y-1][x] == &a[y1][x1]) || (&a[y-2][x] == &a[y1][x1])) 
        {
            if (w[y][x] == 0) return 1;
        // normal move, изначальное положение пешки, возможен ход через клетку
        }
        else return 0;
    }
    if (a[y][x] == 7)
    {
        if ((&a[y + 1][x] == &a[y1][x1]) || (&a[y + 2][x] == &a[y1][x1])) 
        {
            if (w[y][x] == 0) return 1;
        // normal move, изначальное положение пешки, возможен ход через клетку
        }
        else return 0;
    }
}

// перерождение
// функцию возрождения вместо пешки опять пешки придётся делать как-то по-другому
// ибо ей приходится двигаться назад, что не возможно обычной функцией её хода
int Reborn (int a[8][8],int y1, int x1)
{
    int i,j,re,rr=0,p;
    //для белых
	if (a[y1][x1] == 1)
    {
		system("CLS");  
		printf ("2 - elephant\n");
		printf ("3 - horse\n");
		printf ("4 - rook\n");
		printf ("5 - queen\n");
        printf ("Who do you want to revive ?\n");
        
        //добиваемся того, чтобы ввели нужную нам фигуру
        //p - просто флаг, уменьшаем его, если число не верное, увеличиваем и выходим из цикла, если всё верно
        for (p=1;p < 5;p++)
        {
            scanf("%d", &re);
            if ((re==2) || (re==3) || (re==4) || (re==5)) p=p+10;
            else
            {
                p--;
                printf ("No correct, try again !\n");
            }
        }
        //проверяем всё поле, не окажется ли перебор по фигурам
        //так как ферзь всего в игре у белых 1, то сразу увеличиваем счётчик, будто их 2, как и других фигур
        if (re == 5) rr++;
        for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
			{
                if (a[i][j] == re) rr++;
            }
        }
        if (rr < 2) return re;
        else 
        {
            printf ("Now it is тще possible to do\n");
            Reborn (a,y1,x1);
        }
        // запускаем функцию ещё раз, если пытались возродить ненужную фигуру
    }
                
    //для чёрных
    if (a[y1][x1] == 7)
    {
        system("CLS");  
		printf ("8 - elephant\n");
		printf ("9 - horse\n");
		printf ("10 - rook\n");
		printf ("11 - queen\n");
        printf ("Who do you want to revive ?\n");
        
        //добиваемся того, чтобы ввели нужную нам фигуру
        for (p=1;p<5;p++)
        {
            scanf("%d", &re);
            if ((re==8) || (re==9) || (re==10) || (re==11)) p=p+10;
            else 
            {
                p--;
                printf ("No correct, try again !\n");
            }
        }
        
        //проверяем всё поле, не окажется ли перебор по фигурам
        //так как ферзь всего в игре у чёрных 1, то сразу увеличиваем счётчик, будто их 2, как и других фигур
        if (re == 11) rr++;
        for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
			{
                if (a[i][j] == re) rr++;
            }
        }
        if (rr < 2) return re;
        else 
        {
            printf ("Now it is impossible to do\n");
            Reborn (a,y1,x1);
        }
        // запускаем функцию ещё раз, если пытались возродить ненужную фигуру
    
    }
}



//рокировка
void RockW (int a[8][8], int w[8][8], int y, int x, int y1, int x1)
{
    
}

void RockB (int a[8][8], int w[8][8], int y, int x, int y1, int x1)
{
    
}

void SwapMove(int &a, int &b)
{
	b = a;
	a = 0;
}

int CheckMove(int a[8][8], int w[8][8], int y, int x, int y1, int x1) 
//0 - Невозможно походить, 1 - обычный ход, 2 - ход на врага, 3 - ход на союзника, 4-нет фигуры. y-строка x-столбец
{
	int chmove, CheckPlace, k=0, i, j;
	if (a[y][x] != 0)
	{
		if (a[y][x] > 7) chmove = a[y][x];
		else chmove = a[y][x];
		switch (chmove)
		{
			//пешка(белая(ый))
		case 1:
			if ((a[y1][x1] == 0) && (y == 6)) 
				if ((&a[y-1][x] == &a[y1][x1]) || (&a[y-2][x] == &a[y1][x1])) return (Rush(a, w, y, x, y1, x1)); 
			if (a[y1][x1] == 0) 
				if ((&a[y-1][x] == &a[y1][x1])) 
                {
                    w[y][x]=1;
                    return 1; // normal move, любое положение пешки, возможен ход только на клетку вперед
                }
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y - 1][x + 1] == &a[y1][x1]) || (&a[y - 1][x - 1] == &a[y1][x1])) 
				{
                    w[y][x]=1;
                    return 2;
                }
			} // attack
		    if ((&a[y-1][x+1] == &a[y1][x1]) || (&a[y-1][x-1] == &a[y1][x1])) return 3; // alliance
			return 0;
			break;
			
			//слон(белая(ый))
		case 2:
			if ((abs((y1-y))!=abs((x1-x)))||(abs(y1-y)>7)) //если модули раностей двух координат не равны, то ход не возможен 
			{
				return 0;
				break;
			}
			if((y1-y)>0) //игрок ходит в нижнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в нижнюю правую часть доски
				{	
					for(i=y,j=x;(i<y1)&&(j<x1);i++,j++)
					{
						if(a[y1-i][x1-x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в нижнюю левую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i++,j--)
					{
						 if(a[y1-i][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					} 
				}
			}
			if(y-y1>0) //игрок ходит в верхнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в верхнюю правую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i--,j++)
					{
						if(a[i-y1][x1-j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в верхнюю левую часть доски
				{
					for(i=y,j=x;(i>y1)&&(j>x1);i--,j--)
					{
						if(a[i-y1][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((k==(y1-y))||(k==(y-y1))||(k==(x1-x))||(k==(x-x1))) return 1;//normal move 
			else if ((a[y1][x1]>0)&&(a[y1][x1]<=6)) return 3;// alliance
			else if (a[y1][x1]>=7) return 2;// attack
			break;
			
			//конь(белая(ый))
		case 3:
			if(((abs(x1-x) == 1) && (abs(y1-y) == 2))||((abs(x1-x) == 2) && (abs(y1-y) == 1))) 
			{
				if(a[y1][x1] == 0) return 1;
				else if (a[y1][x1]/7 == 0) return 3;
				else return 2;
			}
			else return 0;
			break;

			//ладья(белая(ый))
		case 4:
			if ((x1 != x) && (y1 != y)) return 0; //ход не возможен если обе координаты меняются  
			if (x1==x) //игрок ходит по вертикале 
			{
				if(y1-y>0) //игрок ходит в нижнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[y1-i][x] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(y-y1>0) // игрок ходит в верхнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[i-y1][x]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1==y) //игрок ходит по горизонтале 
			{
				if(x1-x>0) //игрок ходит в правую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][x1-i]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(x-x1>0) // игрок ходит в левую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][i-x1]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if(((x == x1) && (abs(y-y1) == k)) || ((y == y1) && (abs(x-x1) == k))) return 1; //normal move
			else if (a[y1][x1] / 7 == 0) return 3; //alliance
			else return 2; // attack
			break;

			//ферзь(белая(ый))
		case 5:
			if((x1 != x) && (y1 != y) && (abs((y1-y))!=abs((x1-x)))||(abs(y1-y)>7))
			{
				return 0;
				break;
			}
			if((y1-y)>0) //игрок ходит в нижнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в нижнюю правую часть доски
				{	
					for(i=y,j=x;(i<y1) && (j<x1);i++,j++)
					{
						if(a[y1-i][x1-x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в нижнюю левую часть доски
				{
					for(i=y,j=x;(i<y1) && (j>x1);i++,j--)
					{
						 if(a[y1-i][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					} 
				}
			}
			if(y-y1>0) //игрок ходит в верхнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в верхнюю правую часть доски
				{
					for(i=y,j=x;(i<y1) && (j>x1);i--,j++)
					{
						if(a[i-y1][x1-j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в верхнюю левую часть доски
				{
					for(i=y,j=x;(i>y1) && (j>x1);i--,j--)
					{
						if(a[i-y1][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (x1==x) //игрок ходит по вертикале 
			{
				if(y1-y>0) //игрок ходит в нижнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[y1-i][x] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(y-y1>0) // игрок ходит в верхнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[i-y1][x] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1==y) //игрок ходит по горизонтале 
			{
				if(x1-x>0) //игрок ходит в правую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][x1-i] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(x-x1>0) // игрок ходит в левую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][i-x1] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if(((x == x1) && (abs(y-y1) == k)) || ((y == y1) && (abs(x-x1) == k)) || ((k == abs(y1-y)) && ((x1 != x) && (y1 != y)) || ((k == abs(x1-x)) && ((x1 != x) && (y1 != y))))) return 1; //normal move
			else if (a[y1][x1] / 7 == 0) return 3; //alliance
			else return 2;
			break;

			//король(белый))
		case 6:
            
			if ((abs(y1-y) > 1) || (abs(x1-x) > 1)) return 0;//если модуль разностей двух координат больше единицы
            //(то есть кол-во клеток между координатами хода больше единица), то ход не возможен 
			if (a[y1][x1]/7 == 0) return 3;//alliance
				else if(a[y1][x1]/7 == 1) return 2;//attack
					 	else return 1;
			break;


// Вывод массива должен производиться отдельной функцией в мейне, там будет цикл


			//пешка(черная(ый))
		case 7: 
			if ((a[y1][x1] == 0) && (y == 1))
				if ((&a[y + 1][x] == &a[y1][x1]) || (&a[y + 2][x] == &a[y1][x1])) return (Rush(a, w, y, x, y1, x1)); 
                // normal move, изначальное положение пешки, возможен ход через клетку
			if ((a[y1][x1] == 0))
				if ((&a[y + 1][x] == &a[y1][x1]) ) 
                {
                    w[y][x]=1;
                    return 1; // normal move, любое положение пешки, возможен ход только на клетку вперед
                }
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 2;
			} // attack
			if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 3; // alliance
			return 0;
			break;
		
			//слон(чёрная(ый))		
		case 8:
			if ((abs((y1-y))!=abs((x1-x)))||(abs(y1-y)>7)) //если модули раностей двух координат не равны, то ход не возможен 
			{
				return 0;
				break;
			}
			if((y1-y)>0) //игрок ходит в нижнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в нижнюю правую часть доски
				{	
					for(i=y,j=x;(i<y1)&&(j<x1);i++,j++)
					{
						if(a[y1-i][x1-x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в нижнюю левую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i++,j--)
					{
						 if(a[y1-i][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					} 
				}
			}
			if(y-y1>0) //игрок ходит в верхнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в верхнюю правую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i--,j++)
					{
						if(a[i-y1][x1-j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в верхнюю левую часть доски
				{
					for(i=y,j=x;(i>y1)&&(j>x1);i--,j--)
					{
						if(a[i-y1][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, 
                        //если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((k==(y1-y))||(k==(y-y1))||(k==(x1-x))||(k==(x-x1))) return 1;//normal move 
			else if ((a[y1][x1]>0)&&(a[y1][x1]<=6)) return 2;//attack
			else if (a[y1][x1]>=7) return 3;// alliance
			break;	
			
			
		
		
			//конь(чёрная(ый))		
	case 9:
		if(((abs(x1-x) == 1) && (abs(y1-y) == 2))||((abs(x1-x) == 2) && (abs(y1-y) == 1)))
			{
				if(a[y1][x1] == 0) return 1;
				else if (a[y1][x1]/7 == 0) return 3;
				else return 2;
			}
			else return 0;
			break;
			
			//ладья(чёрная(ый))			
	case 10:
		if ((x1 != x) && (y1 != y)) return 0; //ход не возможен если обе координаты меняются
			if (x1==x) //игрок ходит по вертикале 
			{
				if(y1-y>0) //игрок ходит в нижнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[y1-i][x] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(y-y1>0) // игрок ходит в верхнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[i-y1][x]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1==y) //игрок ходит по горизонтале 
			{
				if(x1-x>0) //игрок ходит в правую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][x1-i]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(x-x1>0) // игрок ходит в левую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][i-x1]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if(((x == x1) && (abs(y-y1) == k)) || ((y == y1) && (abs(x-x1) == k))) return 1; //normal move
			else if (a[y1][x1] / 7 == 0) return 2; //alliance
			else return 3; // attack
			break;
			
			//ферзь(чёрная(ый))			
		case 11:
			if (((x1 != x) && (y1 != y)) || ((abs((y1-y))!=abs((x1-x)))||(abs(y1-y)>7)))
			{
				return 0;
				break;
			}
			if((y1-y)>0) //игрок ходит в нижнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в нижнюю правую часть доски
				{	
					for(i=y,j=x;(i<y1)&&(j<x1);i++,j++)
					{
						if(a[y1-i][x1-x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в нижнюю левую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i++,j--)
					{
						 if(a[y1-i][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					} 
				}
			}
			if(y-y1>0) //игрок ходит в верхнюю часть доски
			{
				if((x1-x)>0) //игрок ходит в верхнюю правую часть доски
				{
					for(i=y,j=x;(i<y1)&&(j>x1);i--,j++)
					{
						if(a[i-y1][x1-j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if((x-x1)>0) //игрок ходит в верхнюю левую часть доски
				{
					for(i=y,j=x;(i>y1)&&(j>x1);i--,j--)
					{
						if(a[i-y1][j-x1] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (x1==x) //игрок ходит по вертикале 
			{
				if(y1-y>0) //игрок ходит в нижнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[y1-i][x] == 0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(y-y1>0) // игрок ходит в верхнюю часть доски
				{
					for(i=y;i<y1;i++)
					{
						if (a[i-y1][x]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1==y) //игрок ходит по горизонтале 
			{
				if(x1-x>0) //игрок ходит в правую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][x1-i]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if(x-x1>0) // игрок ходит в левую часть доски
				{
					for(i=x;i<x1;i++)
					{
						if (a[y][i-x1]==0) k++; 
						//ставим счетчик который проверяет условие наличия фигур между координатами хода,
                        // если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if(((x == x1) && (abs(y-y1) == k)) || ((y == y1) && (abs(x-x1) == k)) || (k==(y1-y))||(k==(y-y1))||(k==(x1-x))||(k==(x-x1))) return 1; //normal move
			else if (a[y1][x1] / 7 == 0) return 2; //alliance
			else return 3;//attack
			break;
		
			//король(чёрный)		
		case 12:
			if ((abs(y1-y) > 1) || (abs(x1-x) > 1)) return 0;
            //если модуль разностей двух координат больше единицы
            //(то есть кол-во клеток между координатами хода больше единица), то ход не возможен 
			if (a[y1][x1]/7 == 0) return 2;//attack
			else if(a[y1][x1]/7 == 1) return 3;//alliance
			else return 1;
			break;
	}
}
	else return 4;
}
int main()
{
	int i, j, i1, j1, turn, pass;
	/*
    описываем все элементы шахмотной доски где, 
	белые фигуры <= 6, черные фигу >=7
	1,7-пешка 4,10-ладья 3,9-конь 2,8-слон 5,11-ферзь 6,12-король	
	*/
	a[7][0] = 4; a[6][0] = 1;
	a[7][1] = 3; a[6][1] = 1;
	a[7][2] = 2; a[6][2] = 1;
	a[7][3] = 6; a[6][3] = 1;
	a[7][4] = 5; a[6][4] = 1;
	a[7][5] = 2; a[6][5] = 1;
	a[7][6] = 3; a[6][6] = 1;
	a[7][7] = 4; a[6][7] = 1;
	
	a[4][0] = 0; a[5][0] = 0;
	a[4][1] = 0; a[5][1] = 0;
	a[4][2] = 0; a[5][2] = 0;
	a[4][3] = 0; a[5][3] = 0;
	a[4][4] = 0; a[5][4] = 0;
	a[4][5] = 0; a[5][5] = 0;
	a[4][6] = 0; a[5][6] = 0;
	a[4][7] = 0; a[5][7] = 0;

	a[2][0] = 0; a[3][0] = 0;
	a[2][1] = 0; a[3][1] = 0;
	a[2][2] = 0; a[3][2] = 0;
	a[2][3] = 0; a[3][3] = 0;
	a[2][4] = 0; a[3][4] = 0;
	a[2][5] = 0; a[3][5] = 0;
	a[2][6] = 0; a[3][6] = 0;
	a[2][7] = 0; a[3][7] = 0;

	a[0][0] = 10; a[1][0] = 7;
	a[0][1] = 9; a[1][1] = 7;
	a[0][2] = 8; a[1][2] = 7;
	a[0][3] = 11; a[1][3] = 7;
	a[0][4] = 12; a[1][4] = 7;
	a[0][5] = 8; a[1][5] = 7;
	a[0][6] = 9; a[1][6] = 7;
	a[0][7] = 10; a[1][7] = 7;
	
	/*
	заполняем второй массив"первого хода" для реализации функций:
    рывок пешки и рокировка.
	*/
    for (i=0; i<8; i++)
    {
        for (j = 0; j < 8; j++)
        w[i][j]=0;
    }

	//вывод первоначальной доски, вот такой скучный комментарий 
	for (int cake = 0; cake < 5; cake++)
	{
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
			printf("%2d ", a[i][j]);
			printf("\n");
		}
		
// проверка массива ц
		printf("\n");
			for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
				printf("%2d ", w[i][j]);
			printf("\n");
		}
// удалить в финальной версии

		printf("\n");
		//123
		//ввод координат, где i и j	- кординаты из которых нужно походить,
        // а i1 и j1 - координаты в которые нужно походить, да-да я знаю что можно было сделать лучше 
		printf("input i ");
		scanf("%d", &i);
		printf("input j ");
		scanf("%d", &j);

		printf("input i1 ");
		scanf("%d", &i1);
		printf("input j1 ");
		scanf("%d", &j1);
		printf("Pass = %d\n", CheckMove(a, w, i, j, i1, j1));
		pass = CheckMove(a, w, i, j, i1, j1);
		if (pass == 0) printf("Cake\n");
		if (pass == 3) printf("Cake\n");
		if (pass == 1) SwapMove(a[i][j],a[i1][j1]);
		if (pass == 2) SwapMove(a[i][j],a[i1][j1]);
		if (pass == 4) printf("Cakeislie\n");
		//вызов функции в которой описанны все случаи ходов, нет, 
        //я не переборщил засунов все в одну функцию p.s. смотреть выше в начале проге
        if ( ((i1==0) || (i1==7))&& ((a[i1][j1] == 1) ||(a[i1][j1] == 7)) ) a[i1][j1] = Reborn(a,i1,j1);
		system("Pause");
		system("CLS");
	}
	return 0;
}

